/**
 * Product Specification Export Functionality
 * Handles PDF export for individual product specifications
 * Requirements: 7.1, 7.4, 7.5
 */

class SpecExporter {
  constructor() {
    this.initializeExportButtons();
  }

  /**
   * Initializes export buttons for product specifications
   */
  initializeExportButtons() {
    // Add export button to specification sections
    const specSections = document.querySelectorAll('.product-specs-section');
    
    specSections.forEach(section => {
      this.addExportButton(section);
    });
  }

  /**
   * Adds export button to a specification section
   * @param {HTMLElement} section - Specification section element
   */
  addExportButton(section) {
    // Check if button already exists
    if (section.querySelector('.spec-export-btn')) return;
    
    // Find the main title or create a header area
    let headerArea = section.querySelector('.product-specs__main-title');
    if (!headerArea) {
      headerArea = section.querySelector('.product-specs');
      if (headerArea) {
        const titleDiv = document.createElement('div');
        titleDiv.className = 'product-specs__header';
        headerArea.insertBefore(titleDiv, headerArea.firstChild);
        headerArea = titleDiv;
      }
    }
    
    if (headerArea) {
      // Create export button
      const exportBtn = document.createElement('button');
      exportBtn.type = 'button';
      exportBtn.className = 'spec-export-btn';
      exportBtn.innerHTML = `
        <svg class="spec-export-btn__icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
          <polyline points="14 2 14 8 20 8"/>
          <line x1="16" y1="13" x2="8" y2="13"/>
          <line x1="16" y1="17" x2="8" y2="17"/>
        </svg>
        Export PDF
      `;
      
      // Add event listener
      exportBtn.addEventListener('click', (e) => {
        e.preventDefault();
        this.exportSpecifications(section);
      });
      
      // Style and position the button
      if (headerArea.tagName === 'H2' || headerArea.classList.contains('product-specs__main-title')) {
        // Create a wrapper for title and button
        const wrapper = document.createElement('div');
        wrapper.className = 'product-specs__title-wrapper';
        headerArea.parentNode.insertBefore(wrapper, headerArea);
        wrapper.appendChild(headerArea);
        wrapper.appendChild(exportBtn);
      } else {
        headerArea.appendChild(exportBtn);
      }
    }
  }

  /**
   * Exports specifications from a section to PDF
   * @param {HTMLElement} section - Specification section
   */
  async exportSpecifications(section) {
    try {
      // Show loading state
      const exportBtn = section.querySelector('.spec-export-btn');
      if (exportBtn) {
        exportBtn.disabled = true;
        exportBtn.classList.add('spec-export-btn--loading');
      }
      
      // Extract product data from the page
      const productData = this.extractProductData(section);
      
      // Load PDF exporter if needed
      if (!window.pdfExporter) {
        await this.loadPDFExporter();
      }
      
      // Export to PDF
      const exportOptions = {
        storeName: document.title,
        includeImages: true,
        footerText: 'Generated by Forge Industrial Theme'
      };
      
      await window.pdfExporter.exportSpecifications(productData, exportOptions);
      
    } catch (error) {
      console.error('Specification export failed:', error);
      this.showError('Failed to export specifications: ' + error.message);
    } finally {
      // Remove loading state
      const exportBtn = section.querySelector('.spec-export-btn');
      if (exportBtn) {
        exportBtn.disabled = false;
        exportBtn.classList.remove('spec-export-btn--loading');
      }
    }
  }

  /**
   * Extracts product data from the specification section
   * @param {HTMLElement} section - Specification section
   * @returns {Object} - Product data object
   */
  extractProductData(section) {
    // Try to get product data from various sources
    let productData = {
      id: 'unknown',
      name: 'Product Specifications',
      specifications: {},
      image: null
    };
    
    // Try to get product name from page title or product title
    const productTitle = document.querySelector('.product__title, .product-title, h1');
    if (productTitle) {
      productData.name = productTitle.textContent.trim();
    }
    
    // Try to get product image
    const productImage = document.querySelector('.product__media img, .product-image img, .featured-image img');
    if (productImage) {
      productData.image = productImage.src;
    }
    
    // Extract specifications from tables
    const specTables = section.querySelectorAll('.product-specs__table');
    
    specTables.forEach((table, index) => {
      const categoryName = this.getCategoryName(table, index);
      const categorySpecs = {};
      
      const rows = table.querySelectorAll('.product-specs__row');
      rows.forEach(row => {
        const label = row.querySelector('.product-specs__label');
        const value = row.querySelector('.product-specs__value');
        
        if (label && value) {
          const specKey = this.sanitizeKey(label.textContent.trim());
          const specValue = this.extractSpecValue(value);
          
          if (specKey && specValue) {
            categorySpecs[specKey] = specValue;
          }
        }
      });
      
      if (Object.keys(categorySpecs).length > 0) {
        productData.specifications[categoryName] = categorySpecs;
      }
    });
    
    // Also extract from structured metafield data if available
    const structuredSpecs = section.querySelectorAll('.product-specs__structured .product-specs__category');
    structuredSpecs.forEach(category => {
      const categoryTitle = category.querySelector('.product-specs__title, .product-specs__static-title');
      const categoryName = categoryTitle ? 
        this.sanitizeKey(categoryTitle.textContent.trim()) : 
        `category_${Object.keys(productData.specifications).length}`;
      
      const categorySpecs = {};
      const rows = category.querySelectorAll('.product-specs__row');
      
      rows.forEach(row => {
        const label = row.querySelector('.product-specs__label');
        const value = row.querySelector('.product-specs__value');
        
        if (label && value) {
          const specKey = this.sanitizeKey(label.textContent.trim());
          const specValue = this.extractSpecValue(value);
          
          if (specKey && specValue) {
            categorySpecs[specKey] = specValue;
          }
        }
      });
      
      if (Object.keys(categorySpecs).length > 0) {
        productData.specifications[categoryName] = categorySpecs;
      }
    });
    
    return productData;
  }

  /**
   * Gets category name for a specification table
   * @param {HTMLElement} table - Table element
   * @param {number} index - Table index
   * @returns {string} - Category name
   */
  getCategoryName(table, index) {
    // Look for category title in parent elements
    const category = table.closest('.product-specs__category, .product-specs__accordion');
    if (category) {
      const title = category.querySelector('.product-specs__title, .product-specs__static-title');
      if (title) {
        return this.sanitizeKey(title.textContent.trim());
      }
    }
    
    // Look for preceding headings
    let element = table.previousElementSibling;
    while (element) {
      if (element.tagName && element.tagName.match(/^H[1-6]$/)) {
        return this.sanitizeKey(element.textContent.trim());
      }
      element = element.previousElementSibling;
    }
    
    return `specifications_${index + 1}`;
  }

  /**
   * Extracts specification value from a table cell
   * @param {HTMLElement} valueCell - Value cell element
   * @returns {Object|string} - Specification value object or string
   */
  extractSpecValue(valueCell) {
    const mainValue = valueCell.querySelector('.product-specs__main-value');
    const unit = valueCell.querySelector('.product-specs__unit');
    const tolerance = valueCell.querySelector('.product-specs__tolerance');
    const range = valueCell.querySelector('.product-specs__range');
    const description = valueCell.querySelector('.product-specs__description');
    
    if (mainValue || unit || tolerance || range || description) {
      // Structured value
      const value = {
        value: mainValue ? mainValue.textContent.trim() : valueCell.textContent.trim()
      };
      
      if (unit) value.unit = unit.textContent.trim();
      if (tolerance) value.tolerance = tolerance.textContent.trim();
      if (range) value.range = range.textContent.trim();
      if (description) value.description = description.textContent.trim();
      
      return value;
    } else {
      // Simple text value
      return {
        value: valueCell.textContent.trim()
      };
    }
  }

  /**
   * Sanitizes a key for use in data structures
   * @param {string} key - Original key
   * @returns {string} - Sanitized key
   */
  sanitizeKey(key) {
    return key
      .toLowerCase()
      .replace(/[^a-z0-9]/g, '_')
      .replace(/_+/g, '_')
      .replace(/^_|_$/g, '');
  }

  /**
   * Loads PDF exporter if not already loaded
   */
  async loadPDFExporter() {
    if (window.pdfExporter) return;
    
    try {
      const module = await import('./pdf-export.js');
      if (!window.pdfExporter) {
        window.pdfExporter = new module.default();
      }
    } catch (error) {
      console.error('Failed to load PDF exporter:', error);
      throw new Error('PDF export functionality is not available');
    }
  }

  /**
   * Shows error message
   * @param {string} message - Error message
   */
  showError(message) {
    // Create temporary notification
    const notification = document.createElement('div');
    notification.className = 'spec-export-notification spec-export-notification--error';
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
      notification.remove();
    }, 5000);
  }
}

// Auto-initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    new SpecExporter();
  });
} else {
  new SpecExporter();
}

export default SpecExporter;